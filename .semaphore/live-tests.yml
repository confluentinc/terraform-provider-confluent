version: v1.0
name: Live Integration Tests for Confluent Provider
agent:
  machine:
    type: s1-prod-ubuntu24-04-amd64-2

auto_cancel:
  running:
    when: "false"

global_job_config:
  prologue:
    commands:
      - sem-version go 1.24.4
      - export "GOPATH=$(go env GOPATH)"
      - >-
        export
        "SEMAPHORE_GIT_DIR=${GOPATH}/src/github.com/confluentinc/${SEMAPHORE_PROJECT_NAME}"
      - 'export "PATH=${GOPATH}/bin:${PATH}"'
      - 'mkdir -vp "${SEMAPHORE_GIT_DIR}" "${GOPATH}/bin"'
      - checkout

execution_time_limit:
  hours: 24

blocks:
  - name: "Live Integration Tests"
    task:
      jobs:
        - name: "Run Live Tests"
          commands:
            - . vault-sem-get-secret v1/ci/kv/apif/terraform-provider-confluent/live-testing-data
            - . vault-sem-get-secret v1/ci/kv/apif/terraform-provider-confluent/slack-notifications-live-testing
            - sem-context put slack-webhook-url=$SLACK_WEBHOOK_URL
            - |
              # Map special values and run tests
              case "$TF_LIVE_TEST_GROUPS" in
                "essential") TF_LIVE_TEST_GROUPS="core,kafka" ;;
                "all"|"") TF_LIVE_TEST_GROUPS="" ;;
                *) TF_LIVE_TEST_GROUPS="$TF_LIVE_TEST_GROUPS" ;;
              esac
              
              echo "Running live tests for: ${TF_LIVE_TEST_GROUPS:-all groups}"
              make live-test ${TF_LIVE_TEST_GROUPS:+TF_LIVE_TEST_GROUPS="$TF_LIVE_TEST_GROUPS"}
after_task:
  always:
    commands:
      # This script only executes if the pipeline has failed
      - |
        if [ "$SEMAPHORE_PIPELINE_RESULT" = "failed" ]; then
          echo "Pipeline failed. Sending Slack notification..."

          # Fetch the Slack webhook URL from Vault
          # This script must export the URL into an env var, e.g., SLACK_WEBHOOK_URL
          . vault-sem-get-secret v1/ci/kv/apif/terraform-provider-confluent/slack-notifications-live-testing
        
          # Construct a rich JSON payload for Slack
          COMMIT_AUTHOR=$(git log -1 --pretty=format:'%an')
          MESSAGE_JSON=$(printf '{
            "text": "ðŸš¨ Pipeline Failed: *%s*",
            "blocks": [
              {
                "type": "header",
                "text": { "type": "plain_text", "text": "ðŸš¨ Pipeline Failed: %s" }
              },
              {
                "type": "section",
                "fields": [
                  { "type": "mrkdwn", "text": "*Project:*\n`%s`" },
                  { "type": "mrkdwn", "text": "*Triggered by:*\n%s" }
                ]
              },
              {
                "type": "actions",
                "elements": [
                  {
                    "type": "button",
                    "text": { "type": "plain_text", "text": "View Failed Pipeline" },
                    "style": "danger",
                    "url": "%s"
                  }
                ]
              }
            ]
          }' "$SEMAPHORE_PIPELINE_NAME" "$SEMAPHORE_PIPELINE_NAME" "$SEMAPHORE_PROJECT_NAME" "$SEMAPHORE_WORKFLOW_TRIGGERED_BY" "$SEMAPHORE_PIPELINE_URL")

          # Send the notification using curl
          curl -X POST -H 'Content-type: application/json' --data "$MESSAGE_JSON" $SLACK_WEBHOOK_URL
        fi